//import ts = require("typescript");
import "jassijs_editor/util/Typescript";
//@ts-ignore
import Filesystem from "jassijs/server/Filesystem";



export abstract class Indexer {
    
    abstract fileExists(name);
    abstract readFile(name);
    abstract getFileTime(name);
    abstract createDirectory(name);
    abstract writeFile(name:string,content:string);
    abstract dirFiles(modul:string,path: string, extensions: string[], ignore: string[]): Promise<string[]> ;
  
    public async updateModul(root,modul: string, isserver: boolean ) {
        
        var path = root +(root===""?"":"/") + modul;

        //create empty if needed
        var text = "{}";
        if (await this.fileExists(path + "/registry.js")) {
            text = await this.readFile(path + "/registry.js");
            
            if (!isserver) {
                text = text.substring(text.indexOf("default:") + 8);
                text = text.substring(0, text.lastIndexOf("}") - 1);
                text = text.substring(0, text.lastIndexOf("}") - 1);
            }else{
                text = text.substring(text.indexOf("default=") + 8);
            }
        }
        var index = JSON.parse(text);
        //remove deleted files
        for (var key in index) {
            if (!(await this.fileExists(path + "/" + key))) {
                delete index[key];
            }
        }
 
        var jsFiles: string[] =await  this.dirFiles(modul,path, [".ts"], ["node_modules"])
        for (let x = 0; x < jsFiles.length; x++) {
            var jsFile = jsFiles[x];
            var fileName = jsFile.substring((root.length + (root===""?0:1)));
            if (fileName === undefined)
                continue;
            var entry = index[fileName];
            if (entry === undefined) {
                entry = {};
                entry.date = undefined;
                index[fileName] = entry;
            }
            if (await this.fileExists(root + (root===""?"":"/") + fileName)) {
               
                var dat=await this.getFileTime(root + (root===""?"":"/") + fileName)
                if (dat !== entry.date) {
                    var text =<string> await this.readFile(root + (root===""?"":"/") + fileName);
                    var sourceFile = ts.createSourceFile('hallo.ts', text, ts.ScriptTarget.ES5, true);
                    var outDecorations = [];
                    entry = {};
                    entry.date = undefined;
                    index[fileName] = entry;
                    this.collectAnnotations(sourceFile, entry);
                    // findex(Filesystem.path + "/" + jsFile);
                    entry.date = dat;
                }
            }
        }
        if (!isserver) {//write client

            var text = JSON.stringify(index, undefined, "\t");
            text = "//this file is autogenerated don't modify\n" +
                'define("' + modul + '/registry",["require"], function(require) {\n' +
                ' return {\n' +
                '  default: ' + text + "\n" +
                ' }\n' +
                '});';
            var jsdir = "js/"+path;
            if(Filesystem.path!==undefined)
                jsdir=path.replace(Filesystem.path, Filesystem.path + "/js");
            if (!(await this.fileExists(jsdir)))
                await this.createDirectory(jsdir);
            await this.writeFile(jsdir + "/registry.js", text);
            await this.writeFile(path + "/registry.js", text);
        } else { //write server
            var modules = JSON.parse(await this.readFile("./jassijs.json")).modules;
            for (let smodul in modules) {
                if (modul === smodul) {
                    var text = JSON.stringify(index, undefined, "\t");
                    text = '"use strict:"\n' +
                        "//this file is autogenerated don't modify\n" +
                        'Object.defineProperty(exports, "__esModule", { value: true });\n' +
                        'exports.default=' + text ;
                    var jsdir = "js/" + modul;
                    if (!(await this.fileExists(jsdir)))
                        await this.createDirectory(jsdir);
                    await this.writeFile(jsdir + "/registry.js", text);
                    await this.writeFile(modul + "/registry.js", text);
                }
            }
        }

     }
    
    convertArgument(arg: any) {
        if (arg === undefined)
            return undefined;
        if (arg.kind === ts.SyntaxKind.ObjectLiteralExpression) {
            var ret = {};
            var props = arg.properties;
            if (props !== undefined) {
                for (var p = 0; p < props.length; p++) {
                    ret[props[p].name.text] = this.convertArgument(props[p].initializer);
                }
            }
            return ret;
        } else if (arg.kind === ts.SyntaxKind.StringLiteral) {
            return arg.text;
        } else if (arg.kind === ts.SyntaxKind.ArrayLiteralExpression) {
            let ret = [];
            for (var p = 0; p < arg.elements.length; p++) {
                ret.push(this.convertArgument(arg.elements[p]));
            }
            return ret;
        } else if (arg.kind === ts.SyntaxKind.Identifier) {
            return arg.text;
        } else if (arg.kind === ts.SyntaxKind.TrueKeyword) {
            return true;
        } else if (arg.kind === ts.SyntaxKind.FalseKeyword) {
            return false;
        } else if (arg.kind === ts.SyntaxKind.NumericLiteral) {
            return Number(arg.text);
        }

        throw "Error typ not found";
    }
    collectAnnotations(node: ts.Node, outDecorations, depth = 0) {
        //console.log(new Array(depth + 1).join('----'), node.kind, node.pos, node.end);
        if (node.kind === ts.SyntaxKind.ClassDeclaration) {
            if (node.decorators !== undefined) {
                var dec = {};
                var sclass = undefined;
                for (let x = 0; x < node.decorators.length; x++) {
                    var decnode = node.decorators[x];
                    var ex: any = decnode.expression;
                    if (ex.expression === undefined) {
                        dec[ex.text] = [];//Annotaion without parameter
                    } else {
                        if (ex.expression.text === "$Class")
                            sclass = this.convertArgument(ex.arguments[0]);
                        else {
                            if (dec[ex.expression.text] === undefined) {
                                dec[ex.expression.text] = [];
                            }
                            for (var a = 0; a < ex.arguments.length; a++) {
                                dec[ex.expression.text].push(this.convertArgument(ex.arguments[a]));
                            }
                        }
                    }
                }
                if (sclass !== undefined)
                    outDecorations[sclass] = dec;
            }
        }
        depth++;
        node.getChildren().forEach(c => this.collectAnnotations(c, outDecorations, depth));
    }
    /*findex(file: string) {
        var text = fs.readFileSync(file).toString();
        var sourceFile = ts.createSourceFile('hallo.ts', text, ts.ScriptTarget.ES5, true);
        var outDecorations = [];
        this.collectAnnotations(sourceFile, outDecorations);
        var h = 9;
    }*/
}
