//synchronize-server-client

//import ts = require('typescript');
//import ts = require('typescript'); 
import { exists, myfs, ts } from "jassijs/server/NativeAdapter";
import { JassiError } from "jassijs/remote/Classes";
import Filesystem from "./Filesystem";
import { config } from "jassijs/remote/Config";


//var chokidar = require('chokidar');
/*var path = "./../public_html";
const formatHost: ts.FormatDiagnosticsHost = {
  getCanonicalFileName: path => path,
  getCurrentDirectory: ts.sys.getCurrentDirectory,
  getNewLine: () => ts.sys.newLine
};
var events = require('events');*/
/**
 * compile
 */
export class Compile {

  public static lastModifiedTSFiles: string[] = [];
  lastCompiledTSFiles: string[] = [];


  //private static clientWatcherIsRunning: boolean = false;
  //public static eventEmitter = new events.EventEmitter();
  constructor() {

  }
  serverConfig() {
    var ret: ts.CompilerOptions = {
      baseUrl: "./",
      target: 4,
      module: ts.ModuleKind.CommonJS,
      //"outDir":"js",
      allowJs: true,
      sourceMap: true,
      inlineSources: true,
      moduleResolution: 2,
      skipLibCheck: true,
      rootDir: "./",
      emitDecoratorMetadata: true,
      experimentalDecorators: true,
      noResolve: true
    }
    return ret;
  };
  getDirectoryname(ppath) {
    var path = ppath.replaceAll("\\", "/");
    return path.substring(0, path.lastIndexOf("/"));
  }
  async dirFiles(dirname: string, skip: string[], ret,replaceClientFileName=false) {
    if (!await exists(dirname)) 
      return;
    var files = await myfs.readdir(dirname);
    for (var x = 0; x < files.length; x++) {
      var fname = dirname + "/" + files[x];
      var stat = await myfs.stat(fname);
      if (skip.indexOf(dirname) === -1) {
        if (stat.isDirectory()) {

          await this.dirFiles(fname, skip, ret);
        } else {
          if (fname.endsWith(".js") || fname.endsWith(".ts"))
            if(replaceClientFileName)
              ret[fname.replace("./client/","./")] = await myfs.readFile(fname, "utf-8");
            else
            ret[fname] = await myfs.readFile(fname, "utf-8");
        }
      }
    }
  }
  async readRegistry(file: string, isServer: boolean): Promise<any> {
    var text = await myfs.readFile(file, "utf-8");
    if (!isServer) {
      text = text.substring(text.indexOf("default:") + 8);
      text = text.substring(0, text.lastIndexOf("}") - 1);
      text = text.substring(0, text.lastIndexOf("}") - 1);
    } else {
      text = text.substring(text.indexOf("default=") + 8);
    }
    var index = JSON.parse(text);
    return index;
  }
  async createRegistry(modul: string, isServer: boolean, exclude: string, includeClientRegistry: string, files) {
    var index = await this.readRegistry("./" + (isServer ? "" : "client/") + modul + "/registry.js", isServer);
    var newIndex = {};

    for (var key in index) {
      if (!key.startsWith(exclude))
        newIndex[key] = index[key];
    }
    if (includeClientRegistry !== undefined) {
      var indexc = await this.readRegistry("./client/" + modul + "/registry.js", false);
      for (var key in indexc) {
        if (key.startsWith(includeClientRegistry))
          newIndex[key] = index[key];
      }
    }

    var text = JSON.stringify(newIndex, undefined, "\t");
    text = "//this file is autogenerated don't modify\n" +
      'define("' + modul + '/registry",["require"], function(require) {\n' +
      ' return {\n' +
      '  default: ' + text + "\n" +
      ' }\n' +
      '});';
    files["./" + modul + "/registry.js"] = text;
  }
  async readModuleCode(modul, isServer) {
    var fileNames: { [file: string]: string } = {};
    if (isServer === false) {
      await this.dirFiles("./client/" + modul, ["./client/" + modul + "/server", "./client/" + modul + "/registry.js"], fileNames);
      await this.createRegistry(modul, isServer, modul + "/server", undefined, fileNames);
    } else {
      await this.dirFiles("./" + modul, ["./" + modul + "/server", "./" + modul + "/registry.js"], fileNames);
      await this.dirFiles("./client/" + modul + "/server", [], fileNames,true);
      fileNames["./" + modul + "/modul.ts"] = await myfs.readFile("./client/" + modul + "/modul.ts", "utf-8");

      await this.createRegistry(modul, isServer, modul + "/server", modul + "/server", fileNames);
    }
    return fileNames;
  }
  async transpileModul(modul, isServer) {
    var code = await this.readModuleCode(modul, isServer);
    var writing = [];
    var host: ts.CompilerHost = {
      getSourceFile: (fileName: string, languageVersion: ts.ScriptTarget, onError?: (message: string) => void) => {
        var scode = code["./" + fileName];
        if (scode === undefined)
          debugger;
        return ts.createSourceFile(fileName, scode, languageVersion);
      },
      getDefaultLibFileName: (defaultLibOptions: ts.CompilerOptions) => "",//"/" + ts.getDefaultLibFileName(defaultLibOptions),
      writeFile: (filename, content) => {
        writing.push(myfs.writeFile(filename, content));
      }, // do nothing
      getCurrentDirectory: () => "/",
      getDirectories: (path: string) => [],
      fileExists: (fileName: string) => {
        return code["./" + fileName] !== undefined;
      },
      readFile: (fileName: string) => {
        return code["./" + fileName];
      },
      getCanonicalFileName: (fileName: string) => fileName,
      useCaseSensitiveFileNames: () => true,
      getNewLine: () => "\n",
      getEnvironmentVariable: () => "" // do nothing
    };

    var files = Object.keys(code);
    var opts = this.serverConfig();
    opts.declaration = true;
    opts.outFile = "./dist/" + modul + (isServer ? "-server" : "") + ".js";
    opts.module = ts.ModuleKind.AMD;
    if (!isServer) {
      opts.rootDir = "./client"
    }
    var program = ts.createProgram(files, opts, host);

    let emitResult = program.emit();
    await Promise.all(writing);
    console.log(modul + " " + isServer + " fertig");
  }
  async transpileServercode(fileName: string, inServerdirectory: boolean = undefined) {
    //outDir":"js",
    let spath = fileName.split("/");
    if (!inServerdirectory && spath.length < 2 && spath[1] !== "remote") {
      throw new JassiError("fileName must startswith remote");
    }
    var path = ".";
    var data = await myfs.readFile(path + "/" + fileName, 'utf-8');

    var options: ts.CompilerOptions;
    //if (inServerdirectory === true)
    options = this.serverConfig();
    options.outDir = "js";
    //@ts-ignore
    if (require.main === undefined)//in Browser
      options.module = ts.ModuleKind.AMD;
    //const parsedCmd = ts.getParsedCommandLineOfConfigFile("./tsconfig.json", undefined, host);
    /// const { options } = parsedCmd;
    var outPath = "./js";
    var fdir = outPath + "/" + fileName;
    fdir = fdir.substring(0, fdir.lastIndexOf("/"));
    await myfs.mkdir(fdir, { recursive: true });

    var prefix = "";
    for (let x = 0; x < fileName.split("/").length; x++) {
      prefix = "../" + prefix;
    }
    var content = ts.transpileModule(data, {
      compilerOptions: options,
      fileName: prefix + fileName
    });
    var pathname = "./" + this.getDirectoryname(fileName);
    if (! await exists(pathname)) {
      await myfs.mkdir(pathname, { recursive: true });
    }
    //if (!inServerdirectory)
    //  await myfs.copyFile(new Filesystem().path + "/" + fileName, fileName);
    await myfs.writeFile(outPath + "/" + fileName.replace(".ts", ".js"), content.outputText);
    await myfs.writeFile(outPath + "/" + fileName.replace(".ts", ".js.map"), content.sourceMapText);

  }
  /*
 test(response) {
   const host: ts.ParseConfigFileHost = ts.sys as any;
   // Fix after https://github.com/Microsoft/TypeScript/issues/18217
   //host.onUnRecoverableConfigFileDiagnostic = printDiagnostic;
   const parsedCmd = ts.getParsedCommandLineOfConfigFile(path + "/tsconfig.json", undefined, host);
   const { options, fileNames } = parsedCmd;
   var data = this.compile([path + "/jassijs/base/Registry.ts"], options);
  
   response.send(data);
 }
 compile(fileNames: string[], options: ts.CompilerOptions): string[] {
   var ret = [];
   let program = ts.createProgram(fileNames, options);
   let emitResult = program.emit();

   let allDiagnostics = ts
     .getPreEmitDiagnostics(program)
     .concat(emitResult.diagnostics);

   allDiagnostics.forEach(diagnostic => {
     if (diagnostic.file) {
       let { line, character } = diagnostic.file.getLineAndCharacterOfPosition(
         diagnostic.start!
       );
       let message = ts.flattenDiagnosticMessageText(
         diagnostic.messageText,
         "\n"
       );
       ret.push(`${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`);
       // console.log(
       // `${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`
       //);
     } else {
       ret.push(`${ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n")}`);
       //        console.log(
       //        `${ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n")}`
       //    );
     }
   });

   let exitCode = emitResult.emitSkipped ? 1 : 0;
   ret.push(`Process exiting with code '${exitCode}'.`);
   //console.log(`Process exiting with code '${exitCode}'.`);
   //process.exit(exitCode);
   return ret;
 }

 runWatcher() {
   const configPath = ts.findConfigFile(
     path + "/",
     ts.sys.fileExists,
     "tsconfig.json"
   );
   if (!configPath) {
     throw new JassiError("Could not find a valid 'tsconfig.json'.");
   }
   const createProgram = ts.createSemanticDiagnosticsBuilderProgram;
   const host = ts.createWatchCompilerHost(
     configPath,
     {},
     ts.sys,
     createProgram,
     this.reportDiagnostic.bind(this),
     this.reportWatchStatusChanged.bind(this)
   );

   const origCreateProgram = host.createProgram;
   host.createProgram = (
     rootNames: ReadonlyArray<string>,
     options,
     host,
     oldProgram
   ) => {
     console.log("** We're about to create the program! **");
     return origCreateProgram(rootNames, options, host, oldProgram);
   };
   const origPostProgramCreate = host.afterProgramCreate;
   var test = host.trace;
   //onWatchStatusChange
   //readFile
   //trace
   host.trace = function (s: string) {
     s = s;
   }
   host.afterProgramCreate = program => {
     console.log("** We finished making the program! **");
     origPostProgramCreate!(program);
   };

   // `createWatchProgram` creates an initial program, watches files, and updates
   // the program over time.
   ts.createWatchProgram(host);
 }
 reportDiagnostic(diagnostic: ts.Diagnostic) {
   console.error(
     "Error",
     diagnostic.code,
     ":",
     ts.flattenDiagnosticMessageText(
       diagnostic.messageText,
       formatHost.getNewLine()
     )
   );
 }
 checkNewCompiledFiles(response) {
   var ret = { date: 0, files: [] };
   ret.files = this.lastCompiledTSFiles;
   this.lastCompiledTSFiles = [];
   response.send(JSON.stringify(ret));
   //start the watcher to compile the client code
   var _this = this;
   if (Compile.clientWatcherIsRunning === false) {
     Compile.clientWatcherIsRunning = true;
     this.runWatcher();
     var clientTsHasChanged = function (files, text) {
       for (let f = 0; f < files.length; f++) {
         _this.lastCompiledTSFiles.push(files[f].replace(".ts", ".js").replace("\\", "/"));
       }
       console.log("client changed" + files + " " + text);
     };
     Compile.eventEmitter.addListener("compiled", clientTsHasChanged);
   }
 }

 reportWatchStatusChanged(diagnostic: ts.Diagnostic) {
   let s = ts.formatDiagnostic(diagnostic, formatHost);
   if (diagnostic.code === 6194) {
     Compile.eventEmitter.emit('compiled', Compile.lastModifiedTSFiles, s);
     Compile.lastModifiedTSFiles = [];
     //console.info(Compile.lastModifiedTSFiles);
   }
   console.info(s);
 }*/
}