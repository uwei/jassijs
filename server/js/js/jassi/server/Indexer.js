"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Indexer = void 0;
const ts = require("typescript");
//import "jassi_editor/util/Typescript";
//@ts-ignore
const Filesystem_1 = require("jassi/server/Filesystem");
class Indexer {
    async updateModul(root, modul, isserver) {
        var path = root + (root === "" ? "" : "/") + modul;
        //create empty if needed
        var text = "{}";
        if (await this.fileExists(path + "/registry.js")) {
            text = await this.readFile(path + "/registry.js");
            if (!isserver) {
                text = text.substring(text.indexOf("default:") + 8);
                text = text.substring(0, text.lastIndexOf("}") - 1);
                text = text.substring(0, text.lastIndexOf("}") - 1);
            }
            else {
                text = text.substring(text.indexOf("default=") + 8);
            }
        }
        var index = JSON.parse(text);
        //remove deleted files
        for (var key in index) {
            if (!(await this.fileExists(path + "/" + key))) {
                delete index[key];
            }
        }
        var jsFiles = await new Filesystem_1.default().dirFiles(path, [".ts"], ["node_modules"]);
        for (let x = 0; x < jsFiles.length; x++) {
            var jsFile = jsFiles[x];
            var fileName = jsFile.substring((root.length + 1));
            if (fileName === undefined)
                continue;
            var entry = index[fileName];
            if (entry === undefined) {
                entry = {};
                entry.date = undefined;
                index[fileName] = entry;
            }
            if (await this.fileExists(root + "/" + fileName)) {
                var dat = await this.getFileTime(root + "/" + fileName);
                if (dat !== entry.date) {
                    var text = await this.readFile(root + "/" + fileName);
                    var sourceFile = ts.createSourceFile('hallo.ts', text, ts.ScriptTarget.ES5, true);
                    var outDecorations = [];
                    entry = {};
                    entry.date = undefined;
                    index[fileName] = entry;
                    this.collectAnnotations(sourceFile, entry);
                    // findex(Filesystem.path + "/" + jsFile);
                    entry.date = dat;
                }
            }
        }
        if (!isserver) { //write client
            var text = JSON.stringify(index, undefined, "\t");
            text = "//this file is autogenerated don't modify\n" +
                'define("' + modul + '/registry",["require"], function(require) {\n' +
                ' return {\n' +
                '  default: ' + text + "\n" +
                ' }\n' +
                '});';
            var jsdir = path.replace(Filesystem_1.default.path, Filesystem_1.default.path + "/js");
            if (!(await this.fileExists(jsdir)))
                await this.createDirectory(jsdir);
            await this.writeFile(jsdir + "/registry.js", text);
            await this.writeFile(path + "/registry.js", text);
        }
        else { //write server
            var modules = JSON.parse(await this.readFile("./jassi.json")).modules;
            for (let smodul in modules) {
                if (modul === smodul) {
                    var text = JSON.stringify(index, undefined, "\t");
                    text = '"use strict:"\n' +
                        "//this file is autogenerated don't modify\n" +
                        'Object.defineProperty(exports, "__esModule", { value: true });\n' +
                        'exports.default=' + text;
                    var jsdir = "js/" + modul;
                    if (!(await this.fileExists(jsdir)))
                        await this.createDirectory(jsdir);
                    await this.writeFile(jsdir + "/registry.js", text);
                    await this.writeFile(modul + "/registry.js", text);
                }
            }
        }
    }
    convertArgument(arg) {
        if (arg === undefined)
            return undefined;
        if (arg.kind === ts.SyntaxKind.ObjectLiteralExpression) {
            var ret = {};
            var props = arg.properties;
            if (props !== undefined) {
                for (var p = 0; p < props.length; p++) {
                    ret[props[p].name.text] = this.convertArgument(props[p].initializer);
                }
            }
            return ret;
        }
        else if (arg.kind === ts.SyntaxKind.StringLiteral) {
            return arg.text;
        }
        else if (arg.kind === ts.SyntaxKind.ArrayLiteralExpression) {
            let ret = [];
            for (var p = 0; p < arg.elements.length; p++) {
                ret.push(this.convertArgument(arg.elements[p]));
            }
            return ret;
        }
        else if (arg.kind === ts.SyntaxKind.Identifier) {
            return arg.text;
        }
        else if (arg.kind === ts.SyntaxKind.TrueKeyword) {
            return true;
        }
        else if (arg.kind === ts.SyntaxKind.FalseKeyword) {
            return false;
        }
        else if (arg.kind === ts.SyntaxKind.NumericLiteral) {
            return Number(arg.text);
        }
        throw "Error typ not found";
    }
    collectAnnotations(node, outDecorations, depth = 0) {
        //console.log(new Array(depth + 1).join('----'), node.kind, node.pos, node.end);
        if (node.kind === ts.SyntaxKind.ClassDeclaration) {
            if (node.decorators !== undefined) {
                var dec = {};
                var sclass = undefined;
                for (let x = 0; x < node.decorators.length; x++) {
                    var decnode = node.decorators[x];
                    var ex = decnode.expression;
                    if (ex.expression === undefined) {
                        dec[ex.text] = []; //Annotaion without parameter
                    }
                    else {
                        if (ex.expression.text === "$Class")
                            sclass = this.convertArgument(ex.arguments[0]);
                        else {
                            if (dec[ex.expression.text] === undefined) {
                                dec[ex.expression.text] = [];
                            }
                            for (var a = 0; a < ex.arguments.length; a++) {
                                dec[ex.expression.text].push(this.convertArgument(ex.arguments[a]));
                            }
                        }
                    }
                }
                if (sclass !== undefined)
                    outDecorations[sclass] = dec;
            }
        }
        depth++;
        node.getChildren().forEach(c => this.collectAnnotations(c, outDecorations, depth));
    }
}
exports.Indexer = Indexer;
//# sourceMappingURL=Indexer.js.map