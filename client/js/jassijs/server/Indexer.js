define(["require", "exports", "jassijs/remote/Classes", "jassijs/remote/Config", "jassijs/remote/Serverservice", "jassijs/server/NativeAdapter"], function (require, exports, Classes_1, Config_1, Serverservice_1, NativeAdapter_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Indexer = void 0;
    class Indexer {
        async updateModul(root, modul, isserver) {
            var path = root + (root === "" ? "" : "/") + modul;
            //create empty if needed
            var text = "{}";
            if (await this.fileExists(path + "/registry.js")) {
                text = await this.readFile(path + "/registry.js");
                if (!isserver) {
                    text = text.substring(text.indexOf("default:") + 8);
                    text = text.substring(0, text.lastIndexOf("}") - 1);
                    text = text.substring(0, text.lastIndexOf("}") - 1);
                }
                else {
                    text = text.substring(text.indexOf("default=") + 8);
                }
            }
            try {
                var index = JSON.parse(text);
            }
            catch (_a) {
                console.log("error read modul " + modul + "- create new");
                index = {};
            }
            //remove deleted files
            for (var key in index) {
                if (!(await this.fileExists(root + (root === "" ? "" : "/") + key))) {
                    delete index[key];
                }
            }
            var jsFiles = await this.dirFiles(modul, path, [".ts"], ["node_modules"]);
            for (let x = 0; x < jsFiles.length; x++) {
                var jsFile = jsFiles[x];
                var fileName = jsFile.substring((root.length + (root === "" ? 0 : 1)));
                if (fileName === undefined)
                    continue;
                var entry = index[fileName];
                if (entry === undefined) {
                    entry = {};
                    entry.date = undefined;
                    index[fileName] = entry;
                }
                if (await this.fileExists(root + (root === "" ? "" : "/") + fileName)) {
                    var dat = await this.getFileTime(root + (root === "" ? "" : "/") + fileName);
                    if (dat !== entry.date) {
                        var text = await this.readFile(root + (root === "" ? "" : "/") + fileName);
                        var sourceFile = NativeAdapter_1.ts.createSourceFile('hallo.ts', text, NativeAdapter_1.ts.ScriptTarget.ES5, true);
                        var outDecorations = [];
                        entry = {};
                        entry.date = undefined;
                        index[fileName] = entry;
                        this.collectAnnotations(sourceFile, entry);
                        // findex(Filesystem.path + "/" + jsFile);
                        entry.date = dat;
                    }
                }
            }
            if (!isserver) { //write client
                var text = JSON.stringify(index, undefined, "\t");
                text = "//this file is autogenerated don't modify\n" +
                    'define("' + modul + '/registry",["require"], function(require) {\n' +
                    ' return {\n' +
                    '  default: ' + text + "\n" +
                    ' }\n' +
                    '});';
                var jsdir = "js/" + path;
                var fpath = (await (Serverservice_1.serverservices.filesystem)).path;
                if (fpath !== undefined)
                    jsdir = path.replace(fpath, fpath + "/js");
                if (!(await this.fileExists(jsdir)))
                    await this.createDirectory(jsdir);
                await this.writeFile(jsdir + "/registry.js", text);
                await this.writeFile(path + "/registry.js", text);
            }
            else { //write server
                var modules = Config_1.config.server.modules;
                for (let smodul in modules) {
                    if (modul === smodul) {
                        var text = JSON.stringify(index, undefined, "\t");
                        if (text !== "{}") {
                            text = '"use strict:"\n' +
                                "//this file is autogenerated don't modify\n" +
                                'Object.defineProperty(exports, "__esModule", { value: true });\n' +
                                'exports.default=' + text;
                            var jsdir = "js/" + modul;
                            if (!(await this.fileExists(jsdir)))
                                await this.createDirectory(jsdir);
                            await this.writeFile(jsdir + "/registry.js", text);
                            await this.writeFile(modul + "/registry.js", text);
                        }
                    }
                }
            }
        }
        convertArgument(arg) {
            if (arg === undefined)
                return undefined;
            if (arg.kind === NativeAdapter_1.ts.SyntaxKind.ObjectLiteralExpression) {
                var ret = {};
                var props = arg.properties;
                if (props !== undefined) {
                    for (var p = 0; p < props.length; p++) {
                        ret[props[p].name.text] = this.convertArgument(props[p].initializer);
                    }
                }
                return ret;
            }
            else if (arg.kind === NativeAdapter_1.ts.SyntaxKind.StringLiteral) {
                return arg.text;
            }
            else if (arg.kind === NativeAdapter_1.ts.SyntaxKind.ArrayLiteralExpression) {
                let ret = [];
                for (var p = 0; p < arg.elements.length; p++) {
                    ret.push(this.convertArgument(arg.elements[p]));
                }
                return ret;
            }
            else if (arg.kind === NativeAdapter_1.ts.SyntaxKind.Identifier) {
                return arg.text;
            }
            else if (arg.kind === NativeAdapter_1.ts.SyntaxKind.TrueKeyword) {
                return true;
            }
            else if (arg.kind === NativeAdapter_1.ts.SyntaxKind.FalseKeyword) {
                return false;
            }
            else if (arg.kind === NativeAdapter_1.ts.SyntaxKind.NumericLiteral) {
                return Number(arg.text);
            }
            else if (arg.kind === NativeAdapter_1.ts.SyntaxKind.ArrowFunction || arg.kind === NativeAdapter_1.ts.SyntaxKind.FunctionExpression) {
                return "function";
            }
            throw new Classes_1.JassiError("Error typ not found");
        }
        collectAnnotations(node, outDecorations, depth = 0) {
            var _a;
            //console.log(new Array(depth + 1).join('----'), node.kind, node.pos, node.end);
            if (node.kind === NativeAdapter_1.ts.SyntaxKind.ClassDeclaration) {
                if (node.decorators !== undefined) {
                    var dec = {};
                    var sclass = undefined;
                    for (let x = 0; x < node.decorators.length; x++) {
                        var decnode = node.decorators[x];
                        var ex = decnode.expression;
                        if (ex.expression === undefined) {
                            dec[ex.text] = []; //Annotation without parameter
                        }
                        else {
                            if (ex.expression.text === "$Class")
                                sclass = this.convertArgument(ex.arguments[0]);
                            else {
                                if (dec[ex.expression.text] === undefined) {
                                    dec[ex.expression.text] = [];
                                }
                                for (var a = 0; a < ex.arguments.length; a++) {
                                    dec[ex.expression.text].push(this.convertArgument(ex.arguments[a]));
                                }
                            }
                        }
                    }
                    if (sclass !== undefined)
                        outDecorations[sclass] = dec;
                    //@members.value.$Property=[{name:string}]
                    for (let x = 0; x < node["members"].length; x++) {
                        var member = node["members"][x];
                        var membername = (_a = node["members"][x].name) === null || _a === void 0 ? void 0 : _a.escapedText;
                        if (member.decorators !== undefined) {
                            if (!dec["@members"])
                                dec["@members"] = {};
                            var decm = {};
                            dec["@members"][membername] = decm;
                            for (let x = 0; x < member.decorators.length; x++) {
                                var decnode = member.decorators[x];
                                var ex = decnode.expression;
                                if (ex.expression === undefined) {
                                    decm[ex.text] = []; //Annotation without parameter
                                }
                                else {
                                    if (ex.expression.text === "$Property") {
                                        //do nothing;
                                    }
                                    else {
                                        if (decm[ex.expression.text] === undefined) {
                                            decm[ex.expression.text] = [];
                                        }
                                        for (var a = 0; a < ex.arguments.length; a++) {
                                            decm[ex.expression.text].push(this.convertArgument(ex.arguments[a]));
                                        }
                                    }
                                }
                            }
                            if (Object.keys(dec["@members"][membername]).length === 0) {
                                delete dec["@members"][membername];
                            }
                        }
                    }
                }
            }
            depth++;
            node.getChildren().forEach(c => this.collectAnnotations(c, outDecorations, depth));
        }
    }
    exports.Indexer = Indexer;
});
//# sourceMappingURL=Indexer.js.map