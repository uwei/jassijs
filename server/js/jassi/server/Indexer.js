"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Indexer = void 0;
const ts = require("typescript");
const fs = require("fs");
const Filessystem_1 = require("jassi/server/Filessystem");
class Indexer {
    updateRegistry(modul = undefined, isserver = undefined) {
        if (modul === undefined) {
            //client modules
            var data = fs.readFileSync(Filessystem_1.default.path + "/jassi.json", 'utf-8');
            var modules = JSON.parse(data).modules;
            for (var m in modules) {
                if (!modules[m].endsWith(".js")) //.js are internet modules
                    this.updateRegistry(m, false);
            }
            //server modules
            data = fs.readFileSync("./jassi.json", 'utf-8');
            var modules = JSON.parse(data).modules;
            for (var m in modules) {
                if (!modules[m].endsWith(".js")) //.js are internet modules
                    this.updateRegistry(m, true);
            }
            this.checkRemoteFiles();
            return;
        }
        var path = isserver ? "./" + modul : Filessystem_1.default.path + "/" + modul;
        //create empty if needed
        var text = "{}";
        if (fs.existsSync(path + "/registry.js")) {
            text = fs.readFileSync(path + "/registry.js", 'utf-8');
            if (!isserver) {
                text = text.substring(text.indexOf("default:") + 8);
                text = text.substring(0, text.lastIndexOf("}") - 1);
                text = text.substring(0, text.lastIndexOf("}") - 1);
            }
            else {
                text = text.substring(text.indexOf("default=") + 8);
            }
        }
        var index = JSON.parse(text);
        //remove deleted files
        for (var key in index) {
            if (!fs.existsSync(path + "/" + key)) {
                delete index[key];
            }
        }
        var jsFiles = new Filessystem_1.default().dirFiles(path, [".ts"], ["node_modules"]);
        /* if (fs.existsSync(Filesystem.path + "/remote/" + modul)) {
             var jsFiles2: string[] = new Filesystem().dirFiles(Filesystem.path + "/remote/" + modul, [".ts"], ["node_modules"])
             jsFiles2.forEach((entr) => { jsFiles.push(entr) });
         }*/
        var root = (isserver ? "./" : Filessystem_1.default.path);
        for (let x = 0; x < jsFiles.length; x++) {
            var jsFile = jsFiles[x];
            var fileName = jsFile.substring((root.length + (isserver ? 0 : 1)));
            if (fileName === undefined)
                continue;
            var entry = index[fileName];
            if (entry === undefined) {
                entry = {};
                entry.date = undefined;
                index[fileName] = entry;
            }
            if (fs.existsSync(root + "/" + fileName)) {
                var stats = fs.statSync(root + "/" + fileName);
                if (stats.mtime.getTime() !== entry.date) {
                    var text = fs.readFileSync(root + "/" + fileName).toString();
                    var sourceFile = ts.createSourceFile('hallo.ts', text, ts.ScriptTarget.ES5, true);
                    var outDecorations = [];
                    entry = {};
                    entry.date = undefined;
                    index[fileName] = entry;
                    this.collectAnnotations(sourceFile, entry);
                    // findex(Filesystem.path + "/" + jsFile);
                    entry.date = stats.mtime.getTime();
                }
            }
        }
        if (!isserver) { //write client
            var text = JSON.stringify(index, undefined, "\t");
            text = "//this file is autogenerated don't modify\n" +
                'define("' + modul + '/registry",["require"], function(require) {\n' +
                ' return {\n' +
                '  default: ' + text + "\n" +
                ' }\n' +
                '});';
            var jsdir = path.replace(Filessystem_1.default.path, Filessystem_1.default.path + "/js");
            if (!fs.existsSync(jsdir))
                fs.mkdirSync(jsdir);
            fs.writeFileSync(jsdir + "/registry.js", text);
            fs.writeFileSync(path + "/registry.js", text);
        }
        else { //write server
            var modules = JSON.parse(fs.readFileSync("./jassi.json", 'utf-8')).modules;
            for (let smodul in modules) {
                if (modul === smodul) {
                    var text = JSON.stringify(index, undefined, "\t");
                    text = '"use strict:"\n' +
                        "//this file is autogenerated don't modify\n" +
                        'Object.defineProperty(exports, "__esModule", { value: true });\n' +
                        'exports.default=' + text;
                    var jsdir = "js/" + modul;
                    if (!fs.existsSync(jsdir))
                        fs.mkdirSync(jsdir);
                    fs.writeFileSync(jsdir + "/registry.js", text);
                    fs.writeFileSync(modul + "/registry.js", text);
                }
            }
        }
        //registry.initJSONData(text);
    }
    /**
     * each remote file on server and client should be the same
     */
    checkRemoteFiles() {
        var modules = JSON.parse(fs.readFileSync("./jassi.json", 'utf-8')).modules;
        for (var m in modules) {
            var files = new Filessystem_1.default().dirFiles("./" + m + "/remote", [".ts"]);
            for (let x = 0; x < files.length; x++) {
                var file = files[x];
                var clientfile = file.replace("./", Filessystem_1.default.path + "/");
                if (!fs.existsSync(clientfile)) {
                    console.error(clientfile + " not exists");
                }
                else {
                    if (fs.statSync(file).mtimeMs !== fs.statSync(clientfile).mtimeMs) {
                        if (fs.statSync(file).mtimeMs > fs.statSync(clientfile).mtimeMs) {
                            console.error(clientfile + " is not up to date " + file + " is newer");
                        }
                        else {
                            console.error(file + " is not up to date " + clientfile + " is newer");
                        }
                    }
                }
            }
        }
    }
    convertArgument(arg) {
        if (arg === undefined)
            return undefined;
        if (arg.kind === ts.SyntaxKind.ObjectLiteralExpression) {
            var ret = {};
            var props = arg.properties;
            if (props !== undefined) {
                for (var p = 0; p < props.length; p++) {
                    ret[props[p].name.text] = this.convertArgument(props[p].initializer);
                }
            }
            return ret;
        }
        else if (arg.kind === ts.SyntaxKind.StringLiteral) {
            return arg.text;
        }
        else if (arg.kind === ts.SyntaxKind.ArrayLiteralExpression) {
            let ret = [];
            for (var p = 0; p < arg.elements.length; p++) {
                ret.push(this.convertArgument(arg.elements[p]));
            }
            return ret;
        }
        else if (arg.kind === ts.SyntaxKind.Identifier) {
            return arg.text;
        }
        else if (arg.kind === ts.SyntaxKind.TrueKeyword) {
            return true;
        }
        else if (arg.kind === ts.SyntaxKind.FalseKeyword) {
            return false;
        }
        else if (arg.kind === ts.SyntaxKind.NumericLiteral) {
            return Number(arg.text);
        }
        throw "Error typ not found";
    }
    collectAnnotations(node, outDecorations, depth = 0) {
        //console.log(new Array(depth + 1).join('----'), node.kind, node.pos, node.end);
        if (node.kind === ts.SyntaxKind.ClassDeclaration) {
            if (node.decorators !== undefined) {
                var dec = {};
                var sclass = undefined;
                for (let x = 0; x < node.decorators.length; x++) {
                    var decnode = node.decorators[x];
                    var ex = decnode.expression;
                    if (ex.expression === undefined) {
                        dec[ex.text] = []; //Annotaion without parameter
                    }
                    else {
                        if (ex.expression.text === "$Class")
                            sclass = this.convertArgument(ex.arguments[0]);
                        else {
                            if (dec[ex.expression.text] === undefined) {
                                dec[ex.expression.text] = [];
                            }
                            for (var a = 0; a < ex.arguments.length; a++) {
                                dec[ex.expression.text].push(this.convertArgument(ex.arguments[a]));
                            }
                        }
                    }
                }
                if (sclass !== undefined)
                    outDecorations[sclass] = dec;
            }
        }
        depth++;
        node.getChildren().forEach(c => this.collectAnnotations(c, outDecorations, depth));
    }
}
exports.Indexer = Indexer;
//# sourceMappingURL=Indexer.js.map