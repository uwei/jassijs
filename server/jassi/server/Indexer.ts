import ts = require("typescript");
import fs = require('fs');
import { Any } from "typeorm";
import Filesystem from "jassi/server/Filessystem";

//import jassi from "remote/jassi/base/Jassi";


export class Indexer {

    public updateRegistry(modul: string = undefined) {
        if (modul === undefined) {

            var data = fs.readFileSync(Filesystem.path + "/jassi.json", 'utf-8');
            var modules = JSON.parse(data).modules;
            for (var m in modules) {
                if(!modules[m].endsWith(".js"))//.js are internet modules
                    this.updateRegistry(m);
            }
            /*var files=fs.readdirSync(Filesystem.path);
            for(let f=0;f<files.length;f++){
                var stat = fs.statSync(Filesystem.path+"/"+files[f]);
                if (stat && stat.isDirectory()&&files[f]!=="node_modules"&&
                    files[f]!==".vscode"&&
                    files[f]!=="js") {
                    this.updateRegistry(files[f]);
                }
            }*/
            return;
        }
        var path = Filesystem.path + "/" + modul;
        
        //create empty if needed
        var text = "{}";
        if (fs.existsSync(path + "/registry.js")) {
            text = fs.readFileSync(path + "/registry.js", 'utf-8');
            text = text.substring(text.indexOf("default:") + 8);
            text = text.substring(0, text.lastIndexOf("}") - 1);
            text = text.substring(0, text.lastIndexOf("}") - 1);
        }
        var index = JSON.parse(text);
        //remove deleted files
        for (var key in index) {
            if (!fs.existsSync(path + "/" + key)) {
                delete index[key];
            }
        }
        var jsFiles: string[] = new Filesystem().dirFiles(path, [".ts"], ["node_modules"])
        if(fs.existsSync(Filesystem.path + "/remote/" + modul)){
            var jsFiles2: string[] = new Filesystem().dirFiles(Filesystem.path + "/remote/" + modul, [".ts"], ["node_modules"])
            jsFiles2.forEach((entr)=>{jsFiles.push(entr)});
        }
        for (let x = 0; x < jsFiles.length; x++) {
            var jsFile = jsFiles[x];
            var fileName = jsFile.substring((Filesystem.path.length + 1));
            if (fileName === undefined)
                continue;


            var entry = index[fileName];
            if (entry === undefined) {
                entry = {};
                entry.date = undefined;
                index[fileName] = entry;
            }
            if (fs.existsSync(Filesystem.path + "/" + fileName)) {
                var stats = fs.statSync(Filesystem.path + "/" + fileName);
                if (stats.mtime.getTime() !== entry.date) {
                    var text = fs.readFileSync(Filesystem.path + "/" + fileName).toString();
                    var sourceFile = ts.createSourceFile('hallo.ts', text, ts.ScriptTarget.ES5, true);
                    var outDecorations = [];
                    entry = {};
                    entry.date = undefined;
                    index[fileName] = entry;
                    this.collectAnnotations(sourceFile, entry);
                    // findex(Filesystem.path + "/" + jsFile);

                    entry.date = stats.mtime.getTime();
                }
            }
        }
        var text = JSON.stringify(index, undefined, "\t");
        text = "//this file is autogenerated dont modify\n" +
            'define("' + modul + '/registry",["require"], function(require) {\n' +
            ' return {\n' +
            '  default: ' + text + "\n" +
            ' }\n' +
            '});'
        var jsdir = path.replace(Filesystem.path, Filesystem.path + "/js");
        if (!fs.existsSync(jsdir))
            fs.mkdirSync(jsdir);
        fs.writeFileSync(jsdir + "/registry.js", text);
        fs.writeFileSync(path + "/registry.js", text);
        //registry.initJSONData(text);
    }
    convertArgument(arg: any) {
        if (arg === undefined)
            return undefined;
        if (arg.kind === ts.SyntaxKind.ObjectLiteralExpression) {
            var ret = {};
            var props = arg.properties;
            if (props !== undefined) {
                for (var p = 0; p < props.length; p++) {
                    ret[props[p].name.text] = this.convertArgument(props[p].initializer);
                }
            }
            return ret;
        } else if (arg.kind === ts.SyntaxKind.StringLiteral) {
            return arg.text;
        } else if (arg.kind === ts.SyntaxKind.ArrayLiteralExpression) {
            let ret = [];
            for (var p = 0; p < arg.elements.length; p++) {
                ret.push(this.convertArgument(arg.elements[p]));
            }
            return ret;
        } else if (arg.kind === ts.SyntaxKind.Identifier) {
            return arg.text;
        } else if (arg.kind === ts.SyntaxKind.TrueKeyword) {
            return true;
        } else if (arg.kind === ts.SyntaxKind.FalseKeyword) {
            return false;
        } else if (arg.kind === ts.SyntaxKind.NumericLiteral) {
            return Number(arg.text);
        }

        throw "Error typ not found";
    }
    collectAnnotations(node: ts.Node, outDecorations, depth = 0) {
        //console.log(new Array(depth + 1).join('----'), node.kind, node.pos, node.end);
        if (node.kind === ts.SyntaxKind.ClassDeclaration) {
            if (node.decorators !== undefined) {
                var dec = {};
                var sclass = undefined;
                for (let x = 0; x < node.decorators.length; x++) {
                    var decnode = node.decorators[x];
                    var ex: any = decnode.expression;
                    if (ex.expression === undefined) {
                        dec[ex.text] = [];//Annotaion without parameter
                    } else {
                        if (ex.expression.text === "$Class")
                            sclass = this.convertArgument(ex.arguments[0]);
                        else {
                            if (dec[ex.expression.text] === undefined) {
                                dec[ex.expression.text] = [];
                            }
                            for (var a = 0; a < ex.arguments.length; a++) {
                                dec[ex.expression.text].push(this.convertArgument(ex.arguments[a]));
                            }
                        }
                    }
                }
                if (sclass !== undefined)
                    outDecorations[sclass] = dec;
            }
        }
        depth++;
        node.getChildren().forEach(c => this.collectAnnotations(c, outDecorations, depth));
    }
    /*findex(file: string) {
        var text = fs.readFileSync(file).toString();
        var sourceFile = ts.createSourceFile('hallo.ts', text, ts.ScriptTarget.ES5, true);
        var outDecorations = [];
        this.collectAnnotations(sourceFile, outDecorations);
        var h = 9;
    }*/
}
