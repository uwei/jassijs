//synchronize-server-client
define(["require", "exports", "jassijs/server/NativeAdapter", "jassijs/remote/Classes"], function (require, exports, NativeAdapter_1, Classes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Compile = void 0;
    //var chokidar = require('chokidar');
    /*var path = "./../public_html";
    const formatHost: ts.FormatDiagnosticsHost = {
      getCanonicalFileName: path => path,
      getCurrentDirectory: ts.sys.getCurrentDirectory,
      getNewLine: () => ts.sys.newLine
    };
    var events = require('events');*/
    /**
     * compile
     */
    class Compile {
        //private static clientWatcherIsRunning: boolean = false;
        //public static eventEmitter = new events.EventEmitter();
        constructor() {
            this.lastCompiledTSFiles = [];
        }
        serverConfig() {
            var ret = {
                baseUrl: "./",
                target: 4,
                module: NativeAdapter_1.ts.ModuleKind.CommonJS,
                //"outDir":"js",
                allowJs: true,
                sourceMap: true,
                inlineSources: true,
                moduleResolution: 2,
                skipLibCheck: true,
                rootDir: "./",
                jsx: NativeAdapter_1.ts.JsxEmit.React,
                emitDecoratorMetadata: true,
                experimentalDecorators: true,
                noResolve: true,
                esModuleInterop: true
            };
            return ret;
        }
        ;
        getDirectoryname(ppath) {
            var path = ppath.replaceAll("\\", "/");
            return path.substring(0, path.lastIndexOf("/"));
        }
        async dirFiles(dirname, skip, ret, replaceClientFileName = false) {
            if (!await (0, NativeAdapter_1.exists)(dirname))
                return;
            var files = await NativeAdapter_1.myfs.readdir(dirname);
            for (var x = 0; x < files.length; x++) {
                var fname = dirname + "/" + files[x];
                var stat = await NativeAdapter_1.myfs.stat(fname);
                if (skip.indexOf(dirname) === -1) {
                    if (stat.isDirectory()) {
                        await this.dirFiles(fname, skip, ret);
                    }
                    else {
                        if (fname.endsWith(".js") || fname.endsWith(".ts") || fname.endsWith(".tsx"))
                            if (replaceClientFileName)
                                ret[fname.replace("./client/", "./")] = await NativeAdapter_1.myfs.readFile(fname, "utf-8");
                            else
                                ret[fname] = await NativeAdapter_1.myfs.readFile(fname, "utf-8");
                    }
                }
            }
        }
        async readRegistry(file, isServer) {
            var text = await NativeAdapter_1.myfs.readFile(file, "utf-8");
            if (!isServer) {
                text = text.substring(text.indexOf("default:") + 8);
                text = text.substring(0, text.lastIndexOf("}") - 1);
                text = text.substring(0, text.lastIndexOf("}") - 1);
            }
            else {
                text = text.substring(text.indexOf("default=") + 8);
            }
            if (text === "")
                return undefined;
            var index = JSON.parse(text);
            return index;
        }
        async createRegistry(modul, isServer, exclude, includeClientRegistry, files) {
            var index = await this.readRegistry("./" + (isServer ? "" : "client/") + modul + "/registry.js", isServer);
            var newIndex = {};
            for (var key in index) {
                if (!key.startsWith(exclude))
                    newIndex[key] = index[key];
            }
            if (includeClientRegistry !== undefined) {
                var indexc = await this.readRegistry("./client/" + modul + "/registry.js", false);
                for (var key in indexc) {
                    if (key.startsWith(includeClientRegistry))
                        newIndex[key] = index[key];
                }
            }
            var text = JSON.stringify(newIndex, undefined, "\t");
            text = "//this file is autogenerated don't modify\n" +
                'define("' + modul + '/registry",["require"], function(require) {\n' +
                ' return {\n' +
                '  default: ' + text + "\n" +
                ' }\n' +
                '});';
            files["./" + modul + "/registry.js"] = text;
        }
        async readModuleCode(modul, isServer) {
            var fileNames = {};
            if (isServer === false) {
                await this.dirFiles("./client/" + modul, ["./client/" + modul + "/server", "./client/" + modul + "/registry.js"], fileNames);
                await this.createRegistry(modul, isServer, modul + "/server", undefined, fileNames);
            }
            else {
                await this.dirFiles("./" + modul, ["./" + modul + "/server", "./" + modul + "/registry.js"], fileNames);
                await this.dirFiles("./client/" + modul + "/server", [], fileNames, true);
                fileNames["./" + modul + "/modul.ts"] = await NativeAdapter_1.myfs.readFile("./client/" + modul + "/modul.ts", "utf-8");
                await this.createRegistry(modul, isServer, modul + "/server", modul + "/server", fileNames);
            }
            return fileNames;
        }
        async transpileModul(modul, isServer) {
            var code = await this.readModuleCode(modul, isServer);
            var writing = [];
            var host = {
                getSourceFile: (fileName, languageVersion, onError) => {
                    var scode = code["./" + fileName];
                    if (scode === undefined)
                        debugger;
                    return NativeAdapter_1.ts.createSourceFile(fileName, scode, languageVersion);
                },
                getDefaultLibFileName: (defaultLibOptions) => "",
                writeFile: (filename, content) => {
                    writing.push(NativeAdapter_1.myfs.writeFile(filename, content));
                },
                getCurrentDirectory: () => "/",
                getDirectories: (path) => [],
                fileExists: (fileName) => {
                    return code["./" + fileName] !== undefined;
                },
                readFile: (fileName) => {
                    return code["./" + fileName];
                },
                getCanonicalFileName: (fileName) => fileName,
                useCaseSensitiveFileNames: () => true,
                getNewLine: () => "\n",
                getEnvironmentVariable: () => "" // do nothing
            };
            var files = Object.keys(code);
            var opts = this.serverConfig();
            opts.declaration = true;
            opts.outFile = "./dist/" + modul + (isServer ? "-server" : "") + ".js";
            opts.module = NativeAdapter_1.ts.ModuleKind.AMD;
            if (!isServer) {
                opts.rootDir = "./client";
            }
            var program = NativeAdapter_1.ts.createProgram(files, opts, host);
            let emitResult = program.emit();
            await Promise.all(writing);
            console.log(modul + " " + isServer + " fertig");
        }
        async transpileServercode(fileName, inServerdirectory = undefined) {
            //outDir":"js",
            let spath = fileName.split("/");
            if (!inServerdirectory && spath.length < 2 && spath[1] !== "remote") {
                throw new Classes_1.JassiError("fileName must startswith remote");
            }
            var path = ".";
            var data = await NativeAdapter_1.myfs.readFile(path + "/" + fileName, 'utf-8');
            var options;
            //if (inServerdirectory === true)
            options = this.serverConfig();
            options.outDir = "js";
            //@ts-ignore
            if (require.main === undefined) //in Browser
                options.module = NativeAdapter_1.ts.ModuleKind.AMD;
            //const parsedCmd = ts.getParsedCommandLineOfConfigFile("./tsconfig.json", undefined, host);
            /// const { options } = parsedCmd;
            var outPath = "./js";
            var fdir = outPath + "/" + fileName;
            fdir = fdir.substring(0, fdir.lastIndexOf("/"));
            await NativeAdapter_1.myfs.mkdir(fdir, { recursive: true });
            var prefix = "";
            for (let x = 0; x < fileName.split("/").length; x++) {
                prefix = "../" + prefix;
            }
            var content = NativeAdapter_1.ts.transpileModule(data, {
                compilerOptions: options,
                fileName: prefix + fileName
            });
            var pathname = "./" + this.getDirectoryname(fileName);
            if (!await (0, NativeAdapter_1.exists)(pathname)) {
                await NativeAdapter_1.myfs.mkdir(pathname, { recursive: true });
            }
            //if (!inServerdirectory)
            //  await myfs.copyFile(new Filesystem().path + "/" + fileName, fileName);
            await NativeAdapter_1.myfs.writeFile(outPath + "/" + fileName.replace(".ts", ".js"), content.outputText);
            await NativeAdapter_1.myfs.writeFile(outPath + "/" + fileName.replace(".ts", ".js.map"), content.sourceMapText);
        }
    }
    exports.Compile = Compile;
    Compile.lastModifiedTSFiles = [];
});
//# sourceMappingURL=Compile.js.map